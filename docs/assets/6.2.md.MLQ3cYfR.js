import{_ as e,c as o,o as t,a4 as r}from"./chunks/framework.Cy9JvDAg.js";const _=JSON.parse('{"title":"6.2 - 处理协程","description":"","frontmatter":{"title":"6.2 - 处理协程","footer":true,"lastUpdated":true,"outline":"deep"},"headers":[],"relativePath":"6.2.md","filePath":"6.2.md"}'),a={name:"6.2.md"},n=r('<h2 id="_6-2-处理协程" tabindex="-1">6.2 - 处理协程 <a class="header-anchor" href="#_6-2-处理协程" aria-label="Permalink to &quot;6.2 - 处理协程&quot;">​</a></h2><p>协程库包含了处理协程的相关操作，其都包括在表 coroutine 中。关于协程的描述请参见<a href="/lua5.4-manual-zh/2.6.html">2.6</a>。</p><h3 id="coroutine.close" tabindex="-1">coroutine.close (co) <a class="header-anchor" href="#coroutine.close" aria-label="Permalink to &quot;coroutine.close (co) {#coroutine.close}&quot;">​</a></h3><p>关闭协程 co ，即关闭所有的待关闭变量并将该协程对应的状态机置为死亡状态。所给协程必须处于死亡或挂起状态中。发生错误的情况下（要么是协程的停止过程本身有错误，要么是某些关闭函数发生了错误）返回<strong>false</strong>加上对应的错误对象；否则返回<strong>true</strong>。</p><h3 id="coroutine.create" tabindex="-1">coroutine.create (f) <a class="header-anchor" href="#coroutine.create" aria-label="Permalink to &quot;coroutine.create (f) {#coroutine.create}&quot;">​</a></h3><p>将 f 作为主体创建协程，参数 f 必须是一个函数。返回新创建的协程 —— 一个类型为 &quot;thread&quot; 的对象。</p><h3 id="coroutine.isyieldable" tabindex="-1">coroutine.isyieldable ([co]) <a class="header-anchor" href="#coroutine.isyieldable" aria-label="Permalink to &quot;coroutine.isyieldable (\\[co\\]) {#coroutine.isyieldable}&quot;">​</a></h3><p>如果协程 co 可以让出则返回<strong>true</strong>。参数 co 的默认值时当前正在运行的协程。</p><p>当一个协程不是Lua主线程并且不在一个不可让出的C函数中时，该协程才可以让出。</p><h3 id="coroutine.resume" tabindex="-1">coroutine.resume (co [, val1, ···]) <a class="header-anchor" href="#coroutine.resume" aria-label="Permalink to &quot;coroutine.resume (co [, val1, ···]) {#coroutine.resume}&quot;">​</a></h3><p>开始或继续执行协程 co 。当你首次对协程执行此函数，将会开始运行其主体。其中 val1, ··· 等参数是传递给主体函数的参数。如果之前协程让出了，resume 将会重新启动它，并传入 val1, ··· 等参数作为之前让出的返回值。</p><p>如果协程的运行没有发生错误，resume 将会返回<strong>true</strong>加上让出时传递的值（在协程让出时）或者由主体函数返回的值（当函数执行完毕时）。如果发生了任何错误，resume 会返回<strong>false</strong>加上错误信息。</p><h3 id="coroutine.running" tabindex="-1">coroutine.running () <a class="header-anchor" href="#coroutine.running" aria-label="Permalink to &quot;coroutine.running () {#coroutine.running}&quot;">​</a></h3><p>返回当前运行的协程加上一个布尔值，为<strong>true</strong>时表示此协程是主协程。</p><h3 id="coroutine.status" tabindex="-1">coroutine.status (co) <a class="header-anchor" href="#coroutine.status" aria-label="Permalink to &quot;coroutine.status (co) {#coroutine.status}&quot;">​</a></h3><p>返回表示协程 co 所处状态的字符串：&quot;running&quot; 表示正在运行；&quot;suspended&quot; 表示挂起状态，要么是让出了，要么是还未开始运行；&quot;normal&quot; 表示协程仍然活跃但是没有在运行（即该协程 resume 了另一个协程）；&quot;dead&quot; 表示协程已经执行完了主体函数，或者因为错误而停止了。</p><h3 id="coroutine.wrap" tabindex="-1">coroutine.wrap (f) <a class="header-anchor" href="#coroutine.wrap" aria-label="Permalink to &quot;coroutine.wrap (f) {#coroutine.wrap}&quot;">​</a></h3><p>使用 f 做主体函数来创建协程；参数 f 必须是个函数。返回另一个函数，此每次调用此函数都会 resume 协程。所有传递给这个函数的参数都会作为 resume 的扩展参数传入。此函数除了第一个返回值之外，其余的返回值和 resume 相同。在有错误的情况下，此函数会关闭协程并发出一个错误。</p><h3 id="coroutine.yield" tabindex="-1">coroutine.yield (···) <a class="header-anchor" href="#coroutine.yield" aria-label="Permalink to &quot;coroutine.yield (···) {#coroutine.yield}&quot;">​</a></h3><p>挂起当前运行的协程。任何传入 yield 的参数都会作为之前 resume 的调用结果返回。</p>',20),i=[n];function u(c,s,l,d,h,p){return t(),o("div",null,i)}const f=e(a,[["render",u]]);export{_ as __pageData,f as default};
