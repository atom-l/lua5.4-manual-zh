import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.Cy9JvDAg.js";const E=JSON.parse('{"title":"3.4.7 - 取长操作符","description":"","frontmatter":{"title":"3.4.7 - 取长操作符","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"3.4.7.md","filePath":"3.4.7.md"}'),e={name:"3.4.7.md"},h=t('<h3 id="_3-4-7-取长操作符" tabindex="-1">3.4.7 - 取长操作符 <a class="header-anchor" href="#_3-4-7-取长操作符" aria-label="Permalink to &quot;3.4.7 - 取长操作符&quot;">​</a></h3><p>取长操作符表示为一元前缀 <em>#</em> 。</p><p>这里字符串的长度就是其字节数量。（通常每个字符为单字节时意味着字符串真实长度。）</p><p>表的取长操作返回表的边长（border）。表<em>t</em>的<em>边长</em>是一个满足以下条件的非负整数：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(border </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t[border] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (t[border </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> border </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> math.maxinteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>简单来说，边长是表的一个正整数索引，它的下个索引刚好在表中不存在，然后再加上两条限制：当索引1不存在时，边长为0；以及所存在的索引值最大为整数值的最大值。注意表中存在的非正整数键不会影响其边长。</p><p>一个只有边长的表被称为<em>序列（sequence）</em>。例如，表 {10, 20, 30, 40, 50} 就是一个序列，因为它只有边长（5）以内的键。当表t并不是序列时，#t 也只会返回其边长。（确切地说它取决于表的内部表示，说回来又取决于表的填充方式和非数字键的内存地址。）</p><p>表长度计算的时间复杂度为<em>O(log n)</em>，其中的<em>n</em>为表中的最大整数键。</p><p>在程序中可以通过__len元函数来更改除字符串之外的任意类型的取长操作。</p>',9),n=[h];function p(l,k,r,d,o,_){return a(),i("div",null,n)}const g=s(e,[["render",p]]);export{E as __pageData,g as default};
