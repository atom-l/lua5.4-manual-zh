import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.Cy9JvDAg.js";const E=JSON.parse('{"title":"7 - 单独使用的Lua","description":"","frontmatter":{"title":"7 - 单独使用的Lua","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"7.md","filePath":"7.md"}'),l={name:"7.md"},p=t(`<h1 id="_7-单独使用的lua" tabindex="-1">7 - 单独使用的Lua <a class="header-anchor" href="#_7-单独使用的lua" aria-label="Permalink to &quot;7 - 单独使用的Lua&quot;">​</a></h1><p>尽管Lua被设计为一个扩展语言，用以嵌入在宿主C程序中，但其也经常当作单独的语言使用。Lua的解释器就是一个单独的语言，这里简称为 lua ，其随着标准发行版本一起提供。这个单独的解释器包含了所有标准库。其用法为：</p><pre>lua [options] [script [args]]</pre><p>选项如下：</p><ul><li><strong>-e <em>stat</em>：</strong> 执行字符串 <em>stat</em> 。</li><li><strong>-i：</strong> 在运行脚本后进入交互模式。</li><li><strong>-l <em>mod</em>：</strong> &quot;require&quot; <em>mod</em> 模块并将结果赋值到全局变量 <em>mod</em> 中。</li><li><strong>-l <em>g=mod</em>：</strong> &quot;require&quot; <em>mod</em> 模块并将结果赋值到全局变量 <em>g</em> 中。</li><li><strong>-v：</strong> 打印版本信息。</li><li><strong>-E：</strong> 忽略环境变量。</li><li><strong>-W：</strong> 打开警告。</li><li><strong>--：</strong> 停止处理后边的选项。</li><li><strong>-：</strong> 将 stdin 作为文件来执行并停止处理后边的选项。</li></ul><p>（-l <em>g=mod</em> 选项从5.4.4版本才引入的。）</p><p>在处理其选项后， lua 会运行给定的脚本 <em>scipt</em> 。如果不带任何参数来运行 lua ，那么当其标注输入（stdin）是终端时等效于运行 lua -v -i ，否则等效于运行 lua - 。</p><p>如果没有传入选项 -E ，那么解释器会在运行其他参数前检查环境变量 LUA_INIT_5_4 （或者在没有定义版本名时检查 LUA_INIT ）。如果环境变量的内容是 @<em>filename</em> 形式的，那么 lua 会执行相应文件。否则，lua 只执行其本身的内容。</p><p>如果传入了选项 -E ，那么Lua不会查询任何环境变量。在这种特殊情况下，对于<a href="/lua5.4-manual-zh/6.3.html#package.path">package.path</a>和<a href="/lua5.4-manual-zh/6.3.html#package.cpath">package.cpath</a>会置为定义在 luaconf.h 中的值。</p><p>选项 -e、-l、以及 -W 会被按序处理。例如，像这样的命令：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lua</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a=1&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -llib1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> script.lua</span></span></code></pre></div><p>会先将 a 设为 1，然后再导入库 lib1 ，最后再不带任何参数地运行脚本 script.lua 。（这里的 $ 是 shell 的提示符，你的 shell 中也许会不一样。）</p><p>在运行代码之前，lua 会将所有的命令行参数收集到一个名为 arg 的全局表中。脚本名在表中的索引0处，第一个参数在索引1处，以此类推。任何在脚本文件名之前的命令行参数会是负索引。例如：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lua</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -la</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> b.lua</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> t1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> t2</span></span></code></pre></div><p>中的 arg 表会像这样：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;lua&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-la&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;b.lua&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;t1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;t2&quot; </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果命令中没有脚本名，则解释器的名字会放到索引0处，后边再跟其他的参数。例如：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lua</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;print(arg[1])&quot;</span></span></code></pre></div><p>将会打印 &quot;-e&quot; 。如果有脚本，那么这个脚本会带上参数 arg[1], ···, arg[#arg] 被调用。和所有Lua中的代码块一样，脚本会被编译为一个可变参数函数。</p><p>在交互模式中，Lua会反复打印和等待行输入。在读取了一行后，Lua首先尝试将其翻译为表达式。如果成功了，则打印表达式的值。否则，将其翻译为语句，如果你写了一个不完整的语句，那么解释器会用另一个提示符号来提示你将其完成。</p><p>如果全局变量 _PROMPT 包含一个字符串，那么这个字符串值会被用以作为提示符。类似的，如果全局变量 _PROMPT2 包含一个和字符串，其会被作为第二提示符（提示未完成语句）。</p><p>脚本中发生了不在保护模式下的错误时，解释器会将错误报告到标准错误输出流。如果错误对象不是个字符串但是有元函数 __tostring，那么解释器会调用这个元函数来产生最终的作物信息。否则，解释器会将错误对象转换为一个字符串并加上一个栈回溯信息。当警告打开时，只会简单的打印到标准错误输出中。</p><p>当正常结束时，解释器会关闭Lua主状态机（参见<a href="/lua5.4-manual-zh/4.6.html#lua_close">lua_close</a>）。脚本可以通过调用<a href="/lua5.4-manual-zh/6.9.html#os.exit">os.exit</a>来结束，以避开这个步骤。</p><p>在Unix系统中为了使得Lua可以作为一个脚本解释器，Lua会跳过文件代码块中以 # 号开头的第一行。因此，Lua脚本可以通过使用 chmod +x 命令和将 #! 作为开头，以使得其可以作为一个可直接执行的程序：</p><pre>#!/usr/local/bin/lua</pre><p>当然，在你的机器中，Lua解释器也许不在当前这个位置。如果 lua 在你的 PATH 中的话，那么：</p><pre> #!/usr/bin/env lua</pre><p>是一种更通用的解决方式。</p>`,28),e=[p];function h(n,k,r,o,d,g){return a(),i("div",null,e)}const c=s(l,[["render",h]]);export{E as __pageData,c as default};
