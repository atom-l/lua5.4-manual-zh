import{_ as a,c as e,o as t,a4 as l}from"./chunks/framework.Cy9JvDAg.js";const d=JSON.parse('{"title":"4.4 - C代码中的错误处理","description":"","frontmatter":{"title":"4.4 - C代码中的错误处理","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"4.4.md","filePath":"4.4.md"}'),n={name:"4.4.md"},r=l('<h2 id="_4-4-c代码中的错误处理" tabindex="-1">4.4 - C代码中的错误处理 <a class="header-anchor" href="#_4-4-c代码中的错误处理" aria-label="Permalink to &quot;4.4 - C代码中的错误处理&quot;">​</a></h2><p>在内部，Lua使用C方法longjump来处理错误。（如果你将Lua作为C++代码编译，那么将使用C++异常；相关细节请在源码中搜索LUAI_THROW。）当Lua面对错误时，例如内存分配错误或类型错误，它会<em>抛出</em>错误；即执行一次longjump。<em>保护模式下的环境</em>使用setjmp设置一个恢复点；任何错误都会跳转到最近的活跃恢复点。</p><p>在C函数内部你可以显式调用<a href="/lua5.4-manual-zh/4.6.html#lua_error">lua_error</a>来抛出错误。</p><p>API中的大部分函数都可以抛出错误，例如内存分配错误。本文中对于每个函数都会说明是否可能抛出异常。</p><p>如果在保护模式环境的外部发生了错误，Lua会调用<em>panic函数</em>（see <a href="/lua5.4-manual-zh/4.6.html#lua_atpanic">lua_atpanic</a>）然后调用abort，以此来退出宿主程序。你的panic函数可以永不返回以避免程序退出（例如做一次Lua外部的long jump）。</p><p>panic函数，其顾名思义（panic有陷入恐慌的含义）就是最后的挽救机制，应该在程序中避免。在通用的规则下，当Lua在一个状态机中调用了一个C函数，这个函数对Lua状态机中做的任意操作都应该处于保护模式下。然而当C代码对其他的Lua状态机操作时（例如作为一个是参数传进函数的Lua状态机，另一个是在注册表中存储的Lua状态机，或者还有<a href="/lua5.4-manual-zh/4.6.html#lua_newthread">lua_newthread</a>返回的结果），其应当使用那些不会抛出错误的API调用。</p><p>paninc函数运行方式类似于（错误）消息处理（参见<a href="/lua5.4-manual-zh/2.3.html">2.3</a>）；尤其是错误对象会在栈顶上。然而这里的栈空间没有任何保证。所以panic函数中应当在把一些东西压栈前首先检查其中的可用空间（参见<a href="/lua5.4-manual-zh/4.1.1.html">4.1.1</a>）。</p>',7),u=[r];function _(p,o,c,m,h,i){return t(),e("div",null,u)}const f=a(n,[["render",_]]);export{d as __pageData,f as default};
