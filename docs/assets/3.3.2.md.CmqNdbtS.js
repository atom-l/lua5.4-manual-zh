import{_ as a,c as e,o as t,a4 as s}from"./chunks/framework.Cy9JvDAg.js";const m=JSON.parse('{"title":"3.3.2 - 代码块（Chunks）","description":"","frontmatter":{"title":"3.3.2 - 代码块（Chunks）","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"3.3.2.md","filePath":"3.3.2.md"}'),n={name:"3.3.2.md"},l=s('<h3 id="_3-3-2-代码块-chunks" tabindex="-1">3.3.2 - 代码块（Chunks） <a class="header-anchor" href="#_3-3-2-代码块-chunks" aria-label="Permalink to &quot;3.3.2 - 代码块（Chunks）&quot;">​</a></h3><p>Lua的编译单元称为一个<em>代码块（Chunk）</em>。从语法上说，一个代码块就是一个简单的语句块：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>chunk ::= block</span></span></code></pre></div><p>Lua将一个代码块作为具有可变参数的匿名函数体来处理（参见<a href="/lua5.4-manual-zh/3.4.11.html">3.4.11</a>）。因此，代码块可以定义局部变量、接收参数以及返回值。另外，此匿名函数是在一个称作_ENV的外部局部变量的范围下编译的（参见<a href="/lua5.4-manual-zh/2.2.html">2.2</a>）。这使得函数通常都拥有_ENV作为其唯一的外部局部变量，即使本身没有使用变量。</p><p>代码块可以被存储在文件或宿主程序的字符串中。当执行一个代码块，Lua首先会<em>加载</em>它，将代码块中的代码预编译为虚拟机的指令，然后Lua通过虚拟机的解释器来执行编译后的代码。</p><p>代码块被预编译为二进制形式；细节请参见程序luac和<a href="/lua5.4-manual-zh/6.4.html#string.dump">string.dump</a>函数。程序中的代码形式和编译后形式是可以互换的；Lua会自动检测文件类型并采取相应行动（参见<a href="/lua5.4-manual-zh/6.1.html#load">load</a>）。</p>',6),o=[l];function u(h,r,c,p,_,i){return t(),e("div",null,o)}const f=a(n,[["render",u]]);export{m as __pageData,f as default};
