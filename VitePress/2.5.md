---
title: 2.5 - 垃圾回收（Garbage Collection）
footer: true
lastUpdated: true
outline: false
---

## 2.5 - 垃圾回收（Garbage Collection）
Lua使用自动内存管理。这意味着你不用操心给新对象分配内存或释放不再需要的对象的事。Lua调用*GC（garbage collector）*清理所有的*死亡*对象以自动管理内存。Lua所有使用的内存都由其自动管理：例如字符串、表、userdata、函数、协程、内部结构体……等等。

当收集器确定某个对象在正常的执行或程序中不再会被访问时，这个对象就被认为已经*死亡*了。（这里的“正常的执行”不包括终结器，其可以复活死亡对象；也不包括执行调试库的操作。）注意收集器认为一个对象死亡的时机可能与编程人员的认知有根本上的不同。它只保证在程序的正常执行中可能会被访问的对象不被收集，并最终会在其不可访问时回收对象。（这里说的“不可访问”在Lua中的意思是指某个对象没有被任何值或活跃对象引用。）因为Lua对C代码中的情况一无所知，所以它永远不会收集可以在全局环境（参见[2.2](/2.2)）中通过注册（参见[4.3](/4.3)）来访问的对象。

Lua中的垃圾收集器（GC）有两种工作模式：步进模式和代际模式。

默认参数设置下的默认GC对大多数用户来说已经足够了。然而，有大量浪费在分配和释放内存的耗时程序可以从其他的设置中收益。请记住对于跨平台和跨Lua版本的GC行为是不可移植（non-portable）的，因此优化设置也是不可移植的。

你可以使用不同的参数在C中调用[lua_gc](/4.6#lua_gc)或在Lua中调用[collectgarbage](/6.1#collectgarbage)来改变GC模式。你也可以使用这些函数来直接控制收集器（例如停止或重启它）。