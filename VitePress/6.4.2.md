---
title: 6.4.2 - 打包与解包中的格式化字符串
footer: true
lastUpdated: true
outline: 'deep'
---
### 6.4.2 - 打包与解包中的格式化字符串
在[string.pack](#stringpack-fmt-v1-v2)、[string.packsize](#stringpacksize-fmt)、以及[string.unpack](#stringunpack-fmt-s--pos)中的第一个参数是个格式化字符串，其描述了要创建或读取的结构的布局。

格式化字符串由一系列的转换项组成。这些转换项如下所示：

* **<:** 设为小端编码
* **>:** 设为大端编码
* **=:** 设为原生大小端编码，即跟随本地环境设置。
* **!\[*n*\]:** 将最大对齐设为 n (默认跟随本地环境设置)。
* **b:** 一个有符号字节（char）。
* **B:** 一个无符号字节（char）。
* **h:** 一个有符号 short（取决于本地环境大小）。
* **H:** 一个无符号 short（取决于本地环境大小）。
* **l:** 一个有符号的 long（取决于本地环境大小）。
* **L:** 一个无符号的 long（取决于本地环境大小）。
* **j:** 一个[lua_Integer](#lua_integer)。
* **J:** 一个[lua_Unsigned](#lua_unsigned)。
* **T:** 一个 size_t（取决于本地环境大小）。
* **i\[*n*\]:** 一个大小为 n 个字节的有符号 int（默认为本地环境大小）。
* **I\[*n*\]:** 一个大小为 n 个字节的无符号 int（默认为本地环境大小）。
* **f:** 一个 float（取决于本地环境大小）。
* **d:** 一个 double（取决于本地环境大小）。
* **n:** 一个[lua_Number](#lua_number)。
* **c*n*:** 一个固定长度为 n 字节的字符串。
* **z:** 一个以零为终止符的字符串。
* **s\[n\]:** 一个由表示长度的 n 字节大小整数（默认是 size_t）打头的字符串。
* **x:**  填充一个字节
* **X*op*:** 一个根据转换项 op （其他的会被忽略）来对齐的空对象。 
* **' ':** (空格)无意义，会被忽略。可以用来隔开各个选项以提升可读性。

（"\[*n*\]"的意思是指一个可选的整数。）除了填充、空格以及设置项（"xX <=>!" 这些选项）外，每个选项都需要对应一个在[string.pack](#stringpack-fmt-v1-v2)参数或是[string.unpack](#stringunpack-fmt-s--pos)的结果。

对于 "!*n*"、"s*n*"、"i*n*"、以及 "I*n*" 选项，其中的 *n* 可以是一个1到16之间的整数。所有的整数选项都会检查移除；[string.pack](#stringpack-fmt-v1-v2)会检查所给的值和大小是否合适；[string.unpack](#stringunpack-fmt-s--pos)会检查读取的值是否符合Lua中的整数。对于无符号的选项，Lua解释器也会做类似的无符号数检查。

任何以前缀 "!1=" 开始的格式化字符串的意思是，最大对齐为1字节（即不对齐）并且大小端设置跟随本地环境。

本地的大小端设置假设整个系统要么是大端要么是小端。打包函数无法处理混合大小端模式的行为。

对齐机制如下：对于每个转换项，格式化时会做填充使得数据发生偏移，其偏移量为转换项大小和最大偏移量的最小乘数；其最小乘数必须是2的幂，转换项 "c" 和 "z" 不需要对齐；转换项 "s" 的对齐大小与其开头的整数的大小一致。

[string.pack](#stringpack-fmt-v1-v2)使用零值来做填充并且在[string.unpack](#stringunpack-fmt-s--pos)中会被忽略。
