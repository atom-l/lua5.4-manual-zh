import{_ as a,c as e,o as l,a4 as t}from"./chunks/framework.4aTu-Nia.js";const c=JSON.parse('{"title":"5.1 - 函数和类型","description":"","frontmatter":{"title":"5.1 - 函数和类型","footer":true,"lastUpdated":true,"outline":"deep"},"headers":[],"relativePath":"5.1.md","filePath":"5.1.md"}'),r={name:"5.1.md"},s=t(`<h2 id="_5-1-函数和类型" tabindex="-1">5.1 - 函数和类型 <a class="header-anchor" href="#_5-1-函数和类型" aria-label="Permalink to &quot;5.1 - 函数和类型&quot;">​</a></h2><p>这里按字符序列出了辅助库中的所有函数和类型。</p><h3 id="luaL_addchar" tabindex="-1">luaL_addchar <a class="header-anchor" href="#luaL_addchar" aria-label="Permalink to &quot;luaL_addchar {#luaL_addchar}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>void luaL_addchar (luaL_Buffer *B, char c);</pre><p>将字节 c 添加到缓冲区 B 中（参见<a href="#luaL_Buffer">luaL_Buffer</a>）。</p><h3 id="luaL_addgsub" tabindex="-1">luaL_addgsub <a class="header-anchor" href="#luaL_addgsub" aria-label="Permalink to &quot;luaL_addgsub {#luaL_addgsub}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>const void luaL_addgsub (luaL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre><p>将字符串 s 拷贝到缓冲区 B (参见<a href="#luaL_Buffer">luaL_Buffer</a>)中，并将其中遇到的字符串 p 替换为 字符串 r 。</p><h3 id="luaL_addlstring" tabindex="-1">luaL_addlstring <a class="header-anchor" href="#luaL_addlstring" aria-label="Permalink to &quot;luaL_addlstring {#luaL_addlstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre><p>将 s 所指向的长度为 l 的字符串添加到缓冲区 B （参见<a href="#luaL_Buffer">luaL_Buffer</a>） 中。该字符串可以包含嵌入的零值。</p><h3 id="luaL_addsize" tabindex="-1">luaL_addsize <a class="header-anchor" href="#luaL_addsize" aria-label="Permalink to &quot;luaL_addsize {#luaL_addsize}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>-</em>]</span></p><pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre><p>将之前已经复制到缓冲区 B 中的长度为 n 的字符串添加到其中，即之前已经拷贝到缓冲区的内存了，此时是将大小也合并进去（参见<a href="#luaL_prepbuffer">luaL_prepbuffer</a>）。</p><h3 id="luaL_addstring" tabindex="-1">luaL_addstring <a class="header-anchor" href="#luaL_addstring" aria-label="Permalink to &quot;luaL_addstring {#luaL_addstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre><p>将 s 所指向的一个零为终止符的字符串添加到缓冲区B中（参见<a href="#luaL_Buffer">luaL_Buffer</a>）。</p><h3 id="luaL_addvalue" tabindex="-1">luaL_addvalue <a class="header-anchor" href="#luaL_addvalue" aria-label="Permalink to &quot;luaL_addvalue {#luaL_addvalue}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>void luaL_addvalue (luaL_Buffer *B);</pre><p>将栈顶上的值添加到缓冲区B中（参见<a href="#luaL_Buffer">luaL_Buffer</a>），然后弹出这个值。</p><p>对于字符串缓冲区，这是唯一会额外使用（而且必须使用）栈上元素的函数，这个元素的值会被添加到缓冲区中。</p><h3 id="luaL_argcheck" tabindex="-1">luaL_argcheck <a class="header-anchor" href="#luaL_argcheck" aria-label="Permalink to &quot;luaL_argcheck {#luaL_argcheck}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre><p>检查 cond 是否为真。如果不是，抛出一个关于第 arg 参数的带标准信息的错误（参见<a href="#luaL_argerror">luaL_argerror</a>）。</p><h3 id="luaL_argerror" tabindex="-1">luaL_argerror <a class="header-anchor" href="#luaL_argerror" aria-label="Permalink to &quot;luaL_argerror {#luaL_argerror}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre><p>抛出错误以报告调用C函数的 arg 参数的问题，并使用包含了 extramsg 作为注释的标准信息：</p><pre>bad argument #arg to &#39;funcname&#39; (extramsg)</pre><p>此函数永不返回。</p><h3 id="luaL_argexpected" tabindex="-1">luaL_argexpected <a class="header-anchor" href="#luaL_argexpected" aria-label="Permalink to &quot;luaL_argexpected {#luaL_argexpected}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_argexpected (lua_State *L,
                       int cond,
                       int arg,
                       const char *tname);</pre><p>检查 cond 是否为真。如果不是，抛出一个关于第 arg 参数的类型的带标准信息的错误（参见<a href="#luaL_typeerror">luaL_typeerror</a>）。</p><h3 id="luaL_Buffer" tabindex="-1">luaL_Buffer <a class="header-anchor" href="#luaL_Buffer" aria-label="Permalink to &quot;luaL_Buffer {#luaL_Buffer}&quot;">​</a></h3><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> luaL_Buffer luaL_Buffer;</span></span></code></pre></div><p><em>字符串缓冲区 string buffer</em> 的类型。</p><p>字符串缓冲区允许在C代码中分步构建Lua字符串。其按照如下模式使用：</p><ul><li>首先声明一个<a href="#luaL_Buffer">luaL_Buffer</a>类型的变量 b 。</li><li>然后使用 luaL_buffinit(L, &amp;b) 初始化。</li><li>使用 luaL_add* 类函数来将不同的字符串片段添加到其中。</li><li>最后调用 luaL_pushresult(&amp;b) 。其会将最终的字符串放在栈顶上。</li></ul><p>如果你提前就知道最终的字符串能有多大，那么你可以像这样使用：</p><ul><li>先声明一个<a href="#luaL_Buffer">luaL_Buffer</a>类型的变量 b 。</li><li>然后使用 luaL_buffinitsize(L, &amp;b, sz) 来提前分配 sz 大小的空间并初始化。</li><li>再和之前一样在分配的空间里构建字符串。</li><li>最后调用 luaL_pushresultsize(&amp;b, sz) ，其中 sz 是在缓冲区空间中的最终字符串的长度（其实可能会小于或等于之前分配的大小）。</li></ul><p>一般在以上的操作过程中，字符串缓冲区会使用到不定数目的栈空间。所以当使用缓冲区时，你不可以假设栈顶是已知的。你可以在连续的缓冲区操作之间使用栈，只要能够平衡地去使用它；意思是，当你调用一个缓冲区操作时，栈的层级和上次缓冲区操作后的相同。（这个规则的唯一例外是<a href="#luaL_addvalue">luaL_addvalue</a>。）在调用<a href="#luaL_pushresult">luaL_pushresult</a>后，栈应该回到缓冲区初始化的状态，然后将最终的字符串加到栈顶上。</p><h3 id="luaL_buffaddr" tabindex="-1">luaL_buffaddr <a class="header-anchor" href="#luaL_buffaddr" aria-label="Permalink to &quot;luaL_buffaddr {#luaL_buffaddr}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>char *luaL_buffaddr (luaL_Buffer *B);</pre><p>返回缓冲区 B（参见<a href="#luaL_Buffer">luaL_Buffer</a>）当前内容的地址。注意任何对缓冲区的添加操作都可能使这个地址失效（可能会在内部空间不够的时候重新分配内存）。</p><h3 id="luaL_buffinit" tabindex="-1">luaL_buffinit <a class="header-anchor" href="#luaL_buffinit" aria-label="Permalink to &quot;luaL_buffinit {#luaL_buffinit}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +?, <em>-</em>]</span></p><pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre><p>初始化缓冲区 B（参见<a href="#luaL_Buffer">luaL_Buffer</a>。此函数不会分配任何空间；此缓冲区必须声明为变量。</p><h3 id="luaL_bufflen" tabindex="-1">luaL_bufflen <a class="header-anchor" href="#luaL_bufflen" aria-label="Permalink to &quot;luaL_bufflen {#luaL_bufflen}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>size_t luaL_bufflen (luaL_Buffer *B);</pre><p>返回缓冲区 B（参见<a href="#luaL_Buffer">luaL_Buffer</a>）当前内容的长度。</p><h3 id="luaL_buffinitsize" tabindex="-1">luaL_buffinitsize <a class="header-anchor" href="#luaL_buffinitsize" aria-label="Permalink to &quot;luaL_buffinitsize {#luaL_buffinitsize}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre><p>等效于先后调用<a href="#luaL_buffinit">luaL_buffinit</a>、<a href="#luaL_prepbuffsize">luaL_prepbuffsize</a>。</p><h3 id="luaL_buffsub" tabindex="-1">luaL_buffsub <a class="header-anchor" href="#luaL_buffsub" aria-label="Permalink to &quot;luaL_buffsub {#luaL_buffsub}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>-</em>]</span></p><pre>void luaL_buffsub (luaL_Buffer *B, int n);</pre><p>从缓冲区 B（参见<a href="#luaL_Buffer">luaL_Buffer</a>）中移除 n 个字节。缓冲区中必须有足够的字节。</p><h3 id="luaL_callmeta" tabindex="-1">luaL_callmeta <a class="header-anchor" href="#luaL_callmeta" aria-label="Permalink to &quot;luaL_callmeta {#luaL_callmeta}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +(0|1), <em>e</em>]</span></p><pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre><p>调用某个元函数。</p><p>如果处于索引 obj 处的对象拥有元表并且其中包含字段 e ，那么此函数就会将该对象作为唯一参数调用对应字段。这种情况下此函数会返回 true 并将调用结果压入栈中。如果没有找到元表或元函数，此函数会返回 false 并且不会压栈。</p><h3 id="luaL_checkany" tabindex="-1">luaL_checkany <a class="header-anchor" href="#luaL_checkany" aria-label="Permalink to &quot;luaL_checkany {#luaL_checkany}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_checkany (lua_State *L, int arg);</pre><p>检查函数的参数列表中是否有第 arg 个的任何类型（包括<strong>nil</strong>）参数。</p><h3 id="luaL_checkinteger" tabindex="-1">luaL_checkinteger <a class="header-anchor" href="#luaL_checkinteger" aria-label="Permalink to &quot;luaL_checkinteger {#luaL_checkinteger}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre><p>检查函数的第 n 个参数的类型是否为整数（或者可以转换到整数）并返回其整数值。</p><h3 id="luaL_checklstring" tabindex="-1">luaL_checklstring <a class="header-anchor" href="#luaL_checklstring" aria-label="Permalink to &quot;luaL_checklstring {#luaL_checklstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre><p>检查函数的第 n 个参数的类型是否为字符串并返回这个字符串；参数 l 不为NULL时则会被设为该字符串的长度。</p><p>此函数使用<a href="#lua_tolstring">lua_tolstring</a>获取结果，因此所有相关的转换都可能会生效。</p><h3 id="luaL_checknumber" tabindex="-1">luaL_checknumber <a class="header-anchor" href="#luaL_checknumber" aria-label="Permalink to &quot;luaL_checknumber {#luaL_checknumber}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre><p>检查函数的第 n 个参数的类型是否为 number ，然后将该值转换成 lua_Number 并返回。</p><h3 id="luaL_checkoption" tabindex="-1">luaL_checkoption <a class="header-anchor" href="#luaL_checkoption" aria-label="Permalink to &quot;luaL_checkoption {#luaL_checkoption}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre><p>检查函数的第 arg 个参数类型是否为字符串，并在数组 lst （必须由NULL作为终止标记）中查找字符串。如果找到了就返回在数组中对应的索引下标。如果参数不是个字符串或者查找无果则会抛出错误。</p><p>如果 def 不为 NULL，那么此函数会在没有参数或参数为<strong>nil</strong>时作为其默认值。</p><p>此函数通常被用来匹配C中的枚举值。（在Lua库通常会使用字符串而不是数字作为可选项。）</p><h3 id="luaL_checkstack" tabindex="-1">luaL_checkstack <a class="header-anchor" href="#luaL_checkstack" aria-label="Permalink to &quot;luaL_checkstack {#luaL_checkstack}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre><p>扩充栈空间到 top + sz 个元素。如果无法完成扩充则会抛出错误。参数 msg 指向的文本会被额外添加到错误信息中（或者使用 NULL 表示不添加任何文本）。</p><h3 id="luaL_checkstring" tabindex="-1">luaL_checkstring <a class="header-anchor" href="#luaL_checkstring" aria-label="Permalink to &quot;luaL_checkstring {#luaL_checkstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>const char *luaL_checkstring (lua_State *L, int arg);</pre><p>检查函数的第 arg 个参数类型是否为字符串并返回这个字符串。</p><p>此函数使用<a href="#lua_tolstring">lua_tolstring</a>获取结果，因此所有相关的转换都可能被触发。</p><h3 id="luaL_checktype" tabindex="-1">luaL_checktype <a class="header-anchor" href="#luaL_checktype" aria-label="Permalink to &quot;luaL_checktype {#luaL_checktype}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_checktype (lua_State *L, int arg, int t);</pre><p>检查函数的第 arg 个参数类型是否为 t 。关于 t 所对应的的各类型编码请参见<a href="#lua_type">lua_type</a>。</p><h3 id="luaL_checkudata" tabindex="-1">luaL_checkudata <a class="header-anchor" href="#luaL_checkudata" aria-label="Permalink to &quot;luaL_checkudata {#luaL_checkudata}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre><p>检查函数的第 arg 个参数类型是否为类型名为 tname 的 userdata（参见<a href="#luaL_newmetatable">luaL_newmetatable</a>）并返回其内存块的地址（参见<a href="#lua_touserdata">lua_touserdata</a>）。</p><h3 id="luaL_checkversion" tabindex="-1">luaL_checkversion <a class="header-anchor" href="#luaL_checkversion" aria-label="Permalink to &quot;luaL_checkversion {#luaL_checkversion}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>void luaL_checkversion (lua_State *L);</pre><p>检查正在调用的代码和正在调用的Lua库所使用的Lua版本是否相同，以及相同的数值类型。</p><h3 id="luaL_dofile" tabindex="-1">luaL_dofile <a class="header-anchor" href="#luaL_dofile" aria-label="Permalink to &quot;luaL_dofile {#luaL_dofile}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +?, <em>m</em>]</span></p><pre>int luaL_dofile (lua_State *L, const char *filename);</pre><p>加载并运行指定的文件。是一个如下定义的宏：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luaL_loadfile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L, filename) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lua_pcall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, LUA_MULTRET, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>如果没有错误发生会返回0（<a href="#441---状态码">LUA_OK</a>），否则返回1。</p><h3 id="luaL_dostring" tabindex="-1">luaL_dostring <a class="header-anchor" href="#luaL_dostring" aria-label="Permalink to &quot;luaL_dostring {#luaL_dostring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +?, <em>-</em>]</span></p><pre>int luaL_dostring (lua_State *L, const char *str);</pre><p>加载并运行指定的字符串。是一个如下定义的宏：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luaL_loadstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L, str) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lua_pcall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, LUA_MULTRET, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>如果没有错误发生会返回0（<a href="#441---状态码">LUA_OK</a>），否则返回1。</p><h3 id="luaL_error" tabindex="-1">luaL_error <a class="header-anchor" href="#luaL_error" aria-label="Permalink to &quot;luaL_error {#luaL_error}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre><p>抛出一个错误。其错误信息由 fmt 加上额外的参数格式化而来，遵循和<a href="#lua_pushfstring">lua_pushfstring</a>相同的规则。其也会将遇到错误的文件名和行号加到此错误信息的前面，如果可以找到这些信息的话。</p><p>此函数永不返回，但是可以使用C函数的独有写法 return luaL_error(args) 。</p><h3 id="luaL_execresult" tabindex="-1">luaL_execresult <a class="header-anchor" href="#luaL_execresult" aria-label="Permalink to &quot;luaL_execresult {#luaL_execresult}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +3, <em>m</em>]</span></p><pre>int luaL_execresult (lua_State *L, int stat);</pre><p>此函数用于生成标准库中和线程相关的函数（<a href="/6.9.html#os.execute">os.execute</a>和<a href="/6.8.html#io.close">io.close</a>）的返回值。</p><h3 id="luaL_fileresult" tabindex="-1">luaL_fileresult <a class="header-anchor" href="#luaL_fileresult" aria-label="Permalink to &quot;luaL_fileresult {#luaL_fileresult}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +(1|3), <em>m</em>]</span></p><pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre><p>此函数用于生成标准库中文件相关的函数（<a href="/6.8.html#io.open">io.open</a>、<a href="/6.9.html#os.rename">os.rename</a>、<a href="/6.8.html#file:seek">file:seek</a> 等）的返回值。</p><h3 id="luaL_getmetafield" tabindex="-1">luaL_getmetafield <a class="header-anchor" href="#luaL_getmetafield" aria-label="Permalink to &quot;luaL_getmetafield {#luaL_getmetafield}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +(0|1), <em>m</em>]</span></p><pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre><p>将索引 obj 处的对象的元表中的字段 e 压入栈中，并返回其类型。如果对象没有元表或元表中没有该字段，则不会压栈且返回 LUA_TNIL 。</p><h3 id="luaL_getmetatable" tabindex="-1">luaL_getmetatable <a class="header-anchor" href="#luaL_getmetatable" aria-label="Permalink to &quot;luaL_getmetatable {#luaL_getmetatable}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre><p>将注册表中 tname 的元表压入栈中，或者当不存在相关元表时压入<strong>nil</strong>。返回值为压入栈中的值的类型。</p><h3 id="luaL_getsubtable" tabindex="-1">luaL_getsubtable <a class="header-anchor" href="#luaL_getsubtable" aria-label="Permalink to &quot;luaL_getsubtable {#luaL_getsubtable}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>e</em>]</span></p><pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre><p>确保 t[fname] 的值是一个表并将这个表压入栈中，这里的 t 是索引 idx 处的一个表。当找到这个表时则返回true，否则返回false并创建一个新的表。</p><h3 id="luaL_gsub" tabindex="-1">luaL_gsub <a class="header-anchor" href="#luaL_gsub" aria-label="Permalink to &quot;luaL_gsub {#luaL_gsub}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre><p>创建一个字符串 s 的拷贝，遇到字符串 p 的地方都使用字符串 r 替换。将最终的字符串压入栈中同时并返回。</p><h3 id="luaL_len" tabindex="-1">luaL_len <a class="header-anchor" href="#luaL_len" aria-label="Permalink to &quot;luaL_len {#luaL_len}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>e</em>]</span></p><pre>lua_Integer luaL_len (lua_State *L, int index);</pre><p>将给出索引处的值的“长度”作为一个<a href="#lua_integer">lua_Integer</a>返回；其等效于Lua代码中的&quot;#&quot;操作。如果其结果不是一个整数则会抛出错误（这种情况只会发生在元函数中）。</p><h3 id="luaL_loadbuffer" tabindex="-1">luaL_loadbuffer <a class="header-anchor" href="#luaL_loadbuffer" aria-label="Permalink to &quot;luaL_loadbuffer {#luaL_loadbuffer}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>-</em>]</span></p><pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre><p>等效于参数 mode 传NULL以调用<a href="#luaL_loadbufferx">luaL_loadbufferx</a>。</p><h3 id="luaL_loadbufferx" tabindex="-1">luaL_loadbufferx <a class="header-anchor" href="#luaL_loadbufferx" aria-label="Permalink to &quot;luaL_loadbufferx {#luaL_loadbufferx}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>-</em>]</span></p><pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre><p>将一块缓冲区加载为Lua代码块。此函数使用<a href="#lua_load">lua_load</a>来加载 buff 所指向的长度为 sz 的代码块。</p><p>此函数的返回值同<a href="#lua_load">lua_load</a>。参数 name 是该代码块的名称，用于调试信息和错误消息。字符串参数 mode 用法同<a href="#lua_load">lua_load</a>。</p><h3 id="luaL_loadfile" tabindex="-1">luaL_loadfile <a class="header-anchor" href="#luaL_loadfile" aria-label="Permalink to &quot;luaL_loadfile {#luaL_loadfile}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>int luaL_loadfile (lua_State *L, const char *filename);</pre><p>等效于参数 mode 传NULL以调用<a href="#luaL_loadfilex">luaL_loadfilex</a>。</p><h3 id="luaL_loadfilex" tabindex="-1">luaL_loadfilex <a class="header-anchor" href="#luaL_loadfilex" aria-label="Permalink to &quot;luaL_loadfilex {#luaL_loadfilex}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre><p>将一个文件加载为Lua代码块。此函数使用<a href="#lua_load">lua_load</a>来加载名为 filename 的文件。当 filename 为NULL时会从标准输入中加载。文件中以 &#39;#&#39; 开头的第一行会被忽略。</p><p>字符串参数 mode 用法同<a href="#lua_load">lua_load</a>。</p><p>此函数的返回值同<a href="#lua_load">lua_load</a>或者在发生与文件无关的错误时返回<a href="#441---状态码">LUA_ERRFILE</a>。</p><p>和<a href="#lua_load">lua_load</a>一样，此函数只是加载代码块而不运行。</p><h3 id="luaL_loadstring" tabindex="-1">luaL_loadstring <a class="header-anchor" href="#luaL_loadstring" aria-label="Permalink to &quot;luaL_loadstring {#luaL_loadstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>-</em>]</span></p><pre>int luaL_loadstring (lua_State *L, const char *s);</pre><p>将一个字符串加载为Lua代码块。此函数使用<a href="#lua_load">lua_load</a>来加载以零为终止符的字符串 s 。</p><p>此函数的返回值同<a href="#lua_load">lua_load</a>。</p><p>和<a href="#lua_load">lua_load</a>一样，此函数只是加载代码块而不运行。</p><h3 id="luaL_newlib" tabindex="-1">luaL_newlib <a class="header-anchor" href="#luaL_newlib" aria-label="Permalink to &quot;luaL_newlib {#luaL_newlib}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre><p>创建一个表并将包含在列表 l 中的函数注册在其中。</p><p>其实现为一个如下的宏：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luaL_newlibtable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L,l), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luaL_setfuncs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L,l,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>l 必须传入数组本身，而不是一个指针。</p><h3 id="luaL_newlibtable" tabindex="-1">luaL_newlibtable <a class="header-anchor" href="#luaL_newlibtable" aria-label="Permalink to &quot;luaL_newlibtable {#luaL_newlibtable}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre><p>创建一个足以容纳数组 l 中所有条目的表（但不会真的把它们存进去）。其主要是和<a href="#luaL_setfuncs">luaL_setfuncs</a>组合使用（参见<a href="#luaL_newlib">luaL_newlib</a>）。</p><h3 id="luaL_newmetatable" tabindex="-1">luaL_newmetatable <a class="header-anchor" href="#luaL_newmetatable" aria-label="Permalink to &quot;luaL_newmetatable {#luaL_newmetatable}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre><p>如果注册表中已经存在键 tname ，则直接返回0。否则，创建一个新表用于作为 userdata 的元表，在这个表中添加键值对 __name = tname，再将键值对 [tname] = new tbale 添加到注册表中，并返回1。</p><h3 id="luaL_newstate" tabindex="-1">luaL_newstate <a class="header-anchor" href="#luaL_newstate" aria-label="Permalink to &quot;luaL_newstate {#luaL_newstate}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>lua_State *luaL_newstate (void);</pre><p>创建一个状态机。其会使用一个基于ISO标准C的内存分配函数调用<a href="#lua_newstate">lua_newstate</a>，然后设置警告函数和 panic 函数（参见<a href="/4.4.html">4.4</a>），使之调用时会打印消息到标准错误输出。</p><p>返回值为一个新的状态机，或者在发生内存分配错误时返回NULL。</p><h3 id="luaL_openlibs" tabindex="-1">luaL_openlibs <a class="header-anchor" href="#luaL_openlibs" aria-label="Permalink to &quot;luaL_openlibs {#luaL_openlibs}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>e</em>]</span></p><pre>void luaL_openlibs (lua_State *L);</pre><p>打开给出的状态机中的所有标准库。</p><h3 id="luaL_opt" tabindex="-1">luaL_opt <a class="header-anchor" href="#luaL_opt" aria-label="Permalink to &quot;luaL_opt {#luaL_opt}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>T luaL_opt (L, func, arg, dflt);</pre><p>这个宏的定义如下：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lua_isnoneornil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L,(arg)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dflt) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L,(arg)))</span></span></code></pre></div><p>换言之。如果参数 arg 为<strong>nil</strong>或者缺失，这个宏的结果都是默认的 dflt 。否则，其结果为使用状态机 L 和 arg 作参数的 func 调用结果。注意表达式 dflt 只会在需要的时候被计算。</p><h3 id="luaL_optinteger" tabindex="-1">luaL_optinteger <a class="header-anchor" href="#luaL_optinteger" aria-label="Permalink to &quot;luaL_optinteger {#luaL_optinteger}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre><p>如果函数的第 arg 个参数是一个整数（或可转换为整数），则返回这个整数值。如果参数缺失或为<strong>nil</strong>，则返回 d 。其他情况则会抛出错误。</p><h3 id="luaL_optlstring" tabindex="-1">luaL_optlstring <a class="header-anchor" href="#luaL_optlstring" aria-label="Permalink to &quot;luaL_optlstring {#luaL_optlstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre><p>如果函数的第 arg 个参数是一个字符串，则返回这个字符串。如果参数缺失或为<strong>nil</strong>，则返回 d 。其他情况则会抛出错误。</p><p>如果 l 不为NULL，则会被置为结果的长度。如果结果是NULL（只可能是返回的 d 且 d == NULL），其长度会被视为0。</p><p>此函数使用<a href="#lua_tolstring">lua_tolstring</a>获取结果，因此所有相关的转换都会被触发。</p><h3 id="luaL_optnumber" tabindex="-1">luaL_optnumber <a class="header-anchor" href="#luaL_optnumber" aria-label="Permalink to &quot;luaL_optnumber {#luaL_optnumber}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre><p>如果函数的第 arg 个参数是一个 number ，则将其作为 lua_Number 返回。如果参数缺失或为<strong>nil</strong>，则返回 d 。其他情况则会抛出错误。</p><h3 id="luaL_optstring" tabindex="-1">luaL_optstring <a class="header-anchor" href="#luaL_optstring" aria-label="Permalink to &quot;luaL_optstring {#luaL_optstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre><p>如果函数的第 arg 个参数是一个字符串，则返回这个字符串。如果参数缺失或为<strong>nil</strong>，则返回 d 。其他情况则会抛出错误。</p><h3 id="luaL_prepbuffer" tabindex="-1">luaL_prepbuffer <a class="header-anchor" href="#luaL_prepbuffer" aria-label="Permalink to &quot;luaL_prepbuffer {#luaL_prepbuffer}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre><p>等效于使用预定义的 LUAL_BUFFERSIZE 调用<a href="#luaL_prepbuffsize">luaL_prepbuffsize</a>。</p><h3 id="luaL_prepbuffsize" tabindex="-1">luaL_prepbuffsize <a class="header-anchor" href="#luaL_prepbuffsize" aria-label="Permalink to &quot;luaL_prepbuffsize {#luaL_prepbuffsize}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +?, <em>m</em>]</span></p><pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre><p>返回一个大小为 sz 的内存空间地址以供之后向缓冲区 B（参加<a href="#luaL_Buffer">luaL_Buffer</a>）中复制数据，即提前分配一定的内存而不是在添加时遇到空间不够后再分配。在往其中复制完字符串后你必须调用<a href="#luaL_addsize">luaL_addsize</a>来真正将其添加到缓冲区中。</p><h3 id="luaL_pushfail" tabindex="-1">luaL_pushfail <a class="header-anchor" href="#luaL_pushfail" aria-label="Permalink to &quot;luaL_pushfail {#luaL_pushfail}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>-</em>]</span></p><pre>void luaL_pushfail (lua_State *L);</pre><p>将<strong>fail</strong>值压入栈中（参见<a href="/6.html">6</a>）。</p><h3 id="luaL_pushresult" tabindex="-1">luaL_pushresult <a class="header-anchor" href="#luaL_pushresult" aria-label="Permalink to &quot;luaL_pushresult {#luaL_pushresult}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +1, <em>m</em>]</span></p><pre>void luaL_pushresult (luaL_Buffer *B);</pre><p>结束对缓冲区 B 的使用并将最终的字符串放到栈顶上。</p><h3 id="luaL_pushresultsize" tabindex="-1">luaL_pushresultsize <a class="header-anchor" href="#luaL_pushresultsize" aria-label="Permalink to &quot;luaL_pushresultsize {#luaL_pushresultsize}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-?, +1, <em>m</em>]</span></p><pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre><p>等效于先后执行<a href="#luaL_addsize">luaL_addsize</a>、<a href="#luaL_pushresult">luaL_pushresult</a>。</p><h3 id="luaL_ref" tabindex="-1">luaL_ref <a class="header-anchor" href="#luaL_ref" aria-label="Permalink to &quot;luaL_ref {#luaL_ref}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-1, +0, <em>m</em>]</span></p><pre>int luaL_ref (lua_State *L, int t);</pre><p>在索引 t 处的表中创建并返回一个<em>引用 reference</em> ，其引用的是于栈顶处的对象（并且会弹出栈顶对象）。</p><p>引用是一个唯一的整数键。只要你没有手动给表添加整数键 t ，<a href="#luaL_ref">luaL_ref</a>就会保证其返回的键是唯一的。你可以通过调用 lua_rawgeti(L, t, r) 来取回引用 r 所引用的对象。可以使用[luaL_unref]来释放引用。</p><p>如果栈顶的对象是<strong>nil</strong>，那么<a href="#luaL_ref">luaL_ref</a>会返回常量 LUA_REFNIL 。常量 LUA_NOREF 也绝对不同于<a href="#luaL_ref">luaL_ref</a>返回的引用值。</p><h3 id="luaL_Reg" tabindex="-1">luaL_Reg <a class="header-anchor" href="#luaL_Reg" aria-label="Permalink to &quot;luaL_Reg {#luaL_Reg}&quot;">​</a></h3><pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre><p>用于<a href="#luaL_setfuncs">luaL_setfuncs</a>的注册函数的数组的元素类型。字段 name 是函数的名称，func 是对应的函数指针。任何<a href="#luaL_Reg">luaL_Reg</a>数组都必须以一个name 和 func 字段都是NULL的哨兵条目结尾。</p><h3 id="luaL_requiref" tabindex="-1">luaL_requiref <a class="header-anchor" href="#luaL_requiref" aria-label="Permalink to &quot;luaL_requiref {#luaL_requiref}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>e</em>]</span></p><pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre><p>如果 package.loaded[modname] 结果不为 true 时，会使用字符串 modname 作为函数 openf 的参数传入并调用，并将调用结果放到 package.loaded[modname] 中，就好像这个函数由<a href="/6.3.html#require">require</a>调用的一样。</p><p>如果参数 glb 为true，则将导入的模块也存到与 modname 同名的全局变量中。</p><p>最后会将模块的拷贝到栈顶上。</p><h3 id="luaL_setfuncs" tabindex="-1">luaL_setfuncs <a class="header-anchor" href="#luaL_setfuncs" aria-label="Permalink to &quot;luaL_setfuncs {#luaL_setfuncs}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-nup, +0, <em>m</em>]</span></p><pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre><p>将数组 l（参见<a href="#luaL_Reg">luaL_Reg</a>）中的所有函数注册到栈顶的表中（也可能会在上值下边，见下文）。</p><p>当 nup 不为零时，所有的函数创建时都会带上 nup 个上值，这些上值使用之前压入栈顶的 nup 个值的拷贝来初始化，在栈中这些值的下边才是注册目标的表。这些值都会在注册完之后从栈中弹出。</p><p>当某个 func 的值为NULL时，其表示只占位，在表中注册时会由<strong>false</strong>作为键值填充，即 t[name] = false 。</p><h3 id="luaL_setmetatable" tabindex="-1">luaL_setmetatable <a class="header-anchor" href="#luaL_setmetatable" aria-label="Permalink to &quot;luaL_setmetatable {#luaL_setmetatable}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre><p>将栈顶上对象的元表设置为在注册表中名为 tname 所关联的表（参见<a href="#luaL_newmetatable">luaL_newmetatable</a>）。</p><h3 id="luaL_Stream" tabindex="-1">luaL_Stream <a class="header-anchor" href="#luaL_Stream" aria-label="Permalink to &quot;luaL_Stream {#luaL_Stream}&quot;">​</a></h3><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> luaL_Stream {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FILE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lua_CFunction closef;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} luaL_Stream;</span></span></code></pre></div><p>用于表示标准I/O库中文件句柄的结构。</p><p>文件句柄是作为一个 full userdata 实现的，其带有一个称为 LUA_FILEHANDLE（一个由宏定义的元表名称）的元表。这个元表是由I/O库创建的（参见<a href="#luaL_newmetatable">luaL_newmetatable</a>）。</p><p>其实现的 userdata 中必须由 <a href="#luaL_Stream">luaL_Stream</a>结构作为起始，要包含的其他数据应该放在初始结构的后面。字段 f 指向了其对应的 C stream（或者可以为NULL以表示未完全创建的句柄）。字段 closef 指向了一个当句柄被关闭或回收时用来关闭这个流的函数；此函数接收对应的文件句柄作为唯一的参数，成功时必须返回 true，或折失败的时候返回false加上一个错误消息。一旦Lua调用了这个字段，其就会将该字段置为NULL以表示句柄被关闭了。</p><h3 id="luaL_testudata" tabindex="-1">luaL_testudata <a class="header-anchor" href="#luaL_testudata" aria-label="Permalink to &quot;luaL_testudata {#luaL_testudata}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>m</em>]</span></p><pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre><p>此函数类似于<a href="#luaL_checkudata">luaL_checkudata</a>，不同之处在于，在测试失败的时候会返回NULL而不是抛出错误。</p><h3 id="luaL_tolstring" tabindex="-1">luaL_tolstring <a class="header-anchor" href="#luaL_tolstring" aria-label="Permalink to &quot;luaL_tolstring {#luaL_tolstring}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>e</em>]</span></p><pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre><p>将给出索引处的Lua值用按照可解释的格式转换到C字符串。将结果字符串压入栈中并将其作为该函数的返回值（参见<a href="/4.1.3.html">4.1.3</a>）。如果 len 不为NULL，此函数也会就将 *len 置为该字符串的长度。</p><p>如果给出索引处的Lua值有元表并其中包含了 __tostring 字段，那么<a href="#luaL_tolstring">luaL_tolstring</a>会将此值作为参数来调用相应的元函数，最后将调用结果作为此函数的结果。</p><h3 id="luaL_traceback" tabindex="-1">luaL_traceback <a class="header-anchor" href="#luaL_traceback" aria-label="Permalink to &quot;luaL_traceback {#luaL_traceback}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre><p>新建回溯信息并将其压入到L1的栈中。如果参数 msg 不为 NULL，那么会将其添加到回溯信息的开头。参数 level 指出了从哪一级开始回溯。</p><h3 id="luaL_typeerror" tabindex="-1">luaL_typeerror <a class="header-anchor" href="#luaL_typeerror" aria-label="Permalink to &quot;luaL_typeerror {#luaL_typeerror}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>v</em>]</span></p><pre>int luaL_typeerror (lua_State *L, int arg, const char *tname);</pre><p>抛出一个标准消息格式的类型错误，其和正在调用的C函数的第 arg 个参数相关；参数 tname 是函数需要的类型。此函数永不返回。</p><h3 id="luaL_typename" tabindex="-1">luaL_typename <a class="header-anchor" href="#luaL_typename" aria-label="Permalink to &quot;luaL_typename {#luaL_typename}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>const char *luaL_typename (lua_State *L, int index);</pre><p>返回给定索引处值的类型名。</p><h3 id="luaL_unref" tabindex="-1">luaL_unref <a class="header-anchor" href="#luaL_unref" aria-label="Permalink to &quot;luaL_unref {#luaL_unref}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +0, <em>-</em>]</span></p><pre>void luaL_unref (lua_State *L, int t, int ref);</pre><p>释放索引 index 处表的引用 ref(参见<a href="#luaL_ref">luaL_ref</a>)。因为该条目从表中移除了，所以引用的对象可以被回收。引用 ref 的值释放后也可以再次使用。</p><p>当 ref 值为<a href="#lual_ref">LUA_NOREF</a>或<a href="#lual_ref">LUA_REFNIL</a>时，<a href="#luaL_unref">luaL_unref</a>什么都不会做。</p><h3 id="luaL_where" tabindex="-1">luaL_where <a class="header-anchor" href="#luaL_where" aria-label="Permalink to &quot;luaL_where {#luaL_where}&quot;">​</a></h3><p><span style="color:gray;float:right;font-size:small;">[-0, +1, <em>m</em>]</span></p><pre>void luaL_where (lua_State *L, int lvl);</pre><p>将一个表示当前控制流相对于调用栈的 lvl 层的所在位置的字符串压入栈中。通常这个字符串有以下格式：</p><pre><em>chunkname</em>:<em>currentline</em>:</pre><p>第 0 层为当前运行的函数，第 1 层为调用这个函数的函数，以此类推。</p><p>此函数一般用于构建错误信息的前缀。</p>`,320),u=[s];function i(n,p,o,h,_,L){return l(),e("div",null,u)}const d=a(r,[["render",i]]);export{c as __pageData,d as default};
