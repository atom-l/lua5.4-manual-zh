import{_ as a,c as e,o as t,a4 as _}from"./chunks/framework.4aTu-Nia.js";const h=JSON.parse('{"title":"4 - 应用编程接口","description":"","frontmatter":{"title":"4 - 应用编程接口","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"4.md","filePath":"4.md"}'),u={name:"4.md"},o=_('<h1 id="_4-应用编程接口" tabindex="-1">4 - 应用编程接口 <a class="header-anchor" href="#_4-应用编程接口" aria-label="Permalink to &quot;4 - 应用编程接口&quot;">​</a></h1><p>本章讲述Lua的C API，即可以让宿主程序和Lua通信的C函数集合。所有API函数和相关类型及常量都在头文件lua.h中被定义。</p><p>即使我们说的是术语“函数”，但其实API中的某些工具可能是一个宏。除非另有说明，这些宏内部只使用一次它的参数（除了第一个参数，通常都是Lua状态机对象），因此不会产生任何隐藏的副作用。</p><p>大部分的C库中，Lua的API函数都不会检查参数的有效性和一致性。然而，你可以通过定义Lua的编译宏 LUA_USE_APICHECK 宏来改变此行为。</p><p>Lua库是完全可重入的——它没有全局变量。它把所有需要的信息都保存到一个叫做 <em>Lua状态机（Lua state）</em> 的动态结构中。</p><p>每个Lua状态机都有一个或多个Lua线程（就是协程），它们相互独立，却又共同执行。<a href="/4.6.html#lua_State">lua_State</a>类型（尽管叫这么个名字，很容易让人误会好吗）就引用了单个Lua线程。（Lua线程也间接引用了相关联的Lua状态机。）</p><p>库中每个函数的第一个参数都必须由指向Lua线程的指针传递，除了<a href="/4.6.html#lua_newstate">lua_newstate</a>，此函数会从头创建一个Lua状态机，然后返回一个指向新状态机里的<em>Lua主线程</em>的指针。</p>',7),r=[o];function s(l,n,p,c,i,d){return t(),e("div",null,r)}const m=a(u,[["render",s]]);export{h as __pageData,m as default};
