import{_ as a,c as o,o as s,m as e,a as t}from"./chunks/framework.4aTu-Nia.js";const L=JSON.parse('{"title":"5 - 辅助库","description":"","frontmatter":{"title":"5 - 辅助库","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"5.md","filePath":"5.md"}'),l={name:"5.md"},n=e("h1",{id:"_5-辅助库",tabindex:"-1"},[t("5 - 辅助库 "),e("a",{class:"header-anchor",href:"#_5-辅助库","aria-label":'Permalink to "5 - 辅助库"'},"​")],-1),r=e("p",null,[t("在"),e("em",null,"辅助库 auxiliary library"),t(" 中提供了一系列方便C代码与Lua交互的函数。虽然基础API已经为C代码和LUA交互行为提供了所有的基础函数，但是辅助库可以为组合任务提供更高级的函数。")],-1),_=e("p",null,"辅助库中所有的函数和类型都定义在头文件 lauxlib.h 中，并且名称中都带有前缀“luaL_”。",-1),c=e("p",null,"所有辅助库中的函数都是基于基础API封装的，因此它无法提供API以外的功能。尽管如此，使用辅助库仍然会使得你的代码更加健壮。",-1),i=e("p",null,"辅助库中的一些函数会使用栈中的额外位置。当辅助库某个函数使用的位置少于五个，它将不会检查栈大小；它只是简单地假设栈空间足够。",-1),d=e("p",null,'辅助库中有一些函数会用于检查C函数的参数。因为其错误信息是由参数格式化而来（例如："bad argument #1"），所以你不应该对其他栈值使用这些函数。',-1),u=e("p",null,"luaL_check* 形式的函数总会在不满足检查时抛出错误。",-1),h=[n,r,_,c,i,d,u];function p(m,f,x,P,b,k){return s(),o("div",null,h)}const $=a(l,[["render",p]]);export{L as __pageData,$ as default};
