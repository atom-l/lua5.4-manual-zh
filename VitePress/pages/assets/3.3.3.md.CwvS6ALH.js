import{_ as s,c as a,o as i,a4 as t}from"./chunks/framework.4aTu-Nia.js";const u=JSON.parse('{"title":"3.3.3 - 赋值","description":"","frontmatter":{"title":"3.3.3 - 赋值","footer":true,"lastUpdated":true,"outline":false},"headers":[],"relativePath":"3.3.3.md","filePath":"3.3.3.md"}'),e={name:"3.3.3.md"},p=t(`<h3 id="_3-3-3-赋值" tabindex="-1">3.3.3 - 赋值 <a class="header-anchor" href="#_3-3-3-赋值" aria-label="Permalink to &quot;3.3.3 - 赋值&quot;">​</a></h3><p>Lua允许多重赋值。因此，Lua的赋值语法定义成左边是变量列表而右边是表达式列表。其两边的列表都以逗号分隔元素：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>stat ::= varlist ‘=’ explist</span></span>
<span class="line"><span>varlist ::= var {‘,’ var}</span></span>
<span class="line"><span>explist ::= exp {‘,’ exp}</span></span></code></pre></div><p>表达式参见<a href="/3.4.html">3.4</a>。</p><p>在做赋值操作之前，右侧值列表会被<em>调整</em>至与左侧变量列表长度相同（参见<a href="/3.4.12.html">3.4.12</a>）。</p><p>如果某个变量在多重赋值中同时被读取，那么Lua会确保所有值的读取操作处在赋值之前。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i, a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span></span></code></pre></div><p>因此这段代码会将a[3]设为20，而不会影响a[4]的值，因为a[i]中的的i值在其被赋值为4之前就已经决定了。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y, x</span></span></code></pre></div><p>同理，这行代码会交换x和y的值。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, y, z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y, z, x</span></span></code></pre></div><p>而这行代码会回绕交换x、y、z的值。</p><p>要注意这里的访问语义保证只被涵盖在赋值语句中。如果在赋值期间有方法或元函数改变了变量的值，Lua将不会保证访问顺序。</p><p>全局名称的赋值 x = val 等效于 _ENV.x = val（参见<a href="/2.2.html">2.2</a>）。</p><p>这意味这可以通过元表来改变表属性和全局变量（实际上也是表属性）的赋值（参见<a href="/2.4.html">2.4</a>）。</p>`,15),l=[p];function n(h,d,k,r,o,c){return i(),a("div",null,l)}const E=s(e,[["render",n]]);export{u as __pageData,E as default};
