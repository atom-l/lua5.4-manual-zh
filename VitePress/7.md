---
title: 7 - 单独使用的Lua
footer: true
lastUpdated: true
outline: false
---
# 7 - 单独使用的Lua
尽管Lua被设计为一个扩展语言，用以嵌入在宿主C程序中，但其也经常当作单独的语言使用。Lua的解释器就是一个单独的语言，这里简称为 lua ，其随着标准发行版本一起提供。这个单独的解释器包含了所有标准库。其用法为：

<pre>lua [options] [script [args]]</pre>

选项如下：

* **-e *stat*：** 执行字符串 *stat* 。
* **-i：** 在运行脚本后进入交互模式。
* **-l *mod*：** "require" *mod* 模块并将结果赋值到全局变量 *mod* 中。
* **-l *g=mod*：** "require" *mod* 模块并将结果赋值到全局变量 *g* 中。
* **-v：** 打印版本信息。
* **-E：** 忽略环境变量。
* **-W：** 打开警告。
* **--：** 停止处理后边的选项。
* **-：** 将 stdin 作为文件来执行并停止处理后边的选项。

（-l *g=mod* 选项从5.4.4版本才引入的。）

在处理其选项后， lua 会运行给定的脚本 *scipt* 。如果不带任何参数来运行 lua ，那么当其标注输入（stdin）是终端时等效于运行 lua -v -i ，否则等效于运行 lua - 。

如果没有传入选项 -E ，那么解释器会在运行其他参数前检查环境变量 LUA_INIT_5_4 （或者在没有定义版本名时检查 LUA_INIT ）。如果环境变量的内容是 @*filename* 形式的，那么 lua 会执行相应文件。否则，lua 只执行其本身的内容。

如果传入了选项 -E ，那么Lua不会查询任何环境变量。在这种特殊情况下，对于[package.path](/6.3#package.path)和[package.cpath](/6.3#package.cpath)会置为定义在 luaconf.h 中的值。

选项 -e、-l、以及 -W 会被按序处理。例如，像这样的命令：

```shell
$ lua -e 'a=1' -llib1 script.lua
```

会先将 a 设为 1，然后再导入库 lib1 ，最后再不带任何参数地运行脚本 script.lua 。（这里的 $ 是 shell 的提示符，你的 shell 中也许会不一样。）

在运行代码之前，lua 会将所有的命令行参数收集到一个名为 arg 的全局表中。脚本名在表中的索引0处，第一个参数在索引1处，以此类推。任何在脚本文件名之前的命令行参数会是负索引。例如：
```shell
$ lua -la b.lua t1 t2
```
中的 arg 表会像这样：
```lua
arg = { [-2] = "lua", [-1] = "-la",
        [0] = "b.lua",
        [1] = "t1", [2] = "t2" }
```

如果命令中没有脚本名，则解释器的名字会放到索引0处，后边再跟其他的参数。例如：
```shell
$ lua -e "print(arg[1])"
```
将会打印 "-e" 。如果有脚本，那么这个脚本会带上参数 arg\[1\], ···, arg\[#arg\] 被调用。和所有Lua中的代码块一样，脚本会被编译为一个可变参数函数。

在交互模式中，Lua会反复打印和等待行输入。在读取了一行后，Lua首先尝试将其翻译为表达式。如果成功了，则打印表达式的值。否则，将其翻译为语句，如果你写了一个不完整的语句，那么解释器会用另一个提示符号来提示你将其完成。

如果全局变量 _PROMPT 包含一个字符串，那么这个字符串值会被用以作为提示符。类似的，如果全局变量 _PROMPT2 包含一个和字符串，其会被作为第二提示符（提示未完成语句）。

脚本中发生了不在保护模式下的错误时，解释器会将错误报告到标准错误输出流。如果错误对象不是个字符串但是有元函数 __tostring，那么解释器会调用这个元函数来产生最终的作物信息。否则，解释器会将错误对象转换为一个字符串并加上一个栈回溯信息。当警告打开时，只会简单的打印到标准错误输出中。

当正常结束时，解释器会关闭Lua主状态机（参见[lua_close](/4.6#lua_close)）。脚本可以通过调用[os.exit](/6.9#os.exit)来结束，以避开这个步骤。

在Unix系统中为了使得Lua可以作为一个脚本解释器，Lua会跳过文件代码块中以 # 号开头的第一行。因此，Lua脚本可以通过使用 chmod +x 命令和将 #! 作为开头，以使得其可以作为一个可直接执行的程序：
<pre>#!/usr/local/bin/lua</pre>
当然，在你的机器中，Lua解释器也许不在当前这个位置。如果 lua 在你的 PATH 中的话，那么：
<pre> #!/usr/bin/env lua</pre>
是一种更通用的解决方式。
